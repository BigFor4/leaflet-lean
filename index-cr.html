<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Display Multiple Lines with Different Labels</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        #map {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        .labelLine {
            font-size: 12px;
            font-weight: bold;
            color: red;
            text-align: center;
        }

        .labelLineCenter {
            font-size: 12px;
            font-weight: bold;
            color: blue;
            text-align: center;
        }

        .pointDraw {
            background-color: green;
            border: 2px solid black;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            z-index: 1000 !important;
        }

        .pointDrawCenter {
            background-color: rgba(0, 128, 0, 0.267);
            border: 2px solid rgba(0, 0, 0, 0.267);
            border-radius: 50%;
            width: 15px;
            height: 15px;
            z-index: 1000 !important;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <p><a href="https://www.maptiler.com/copyright/" target="_blank" rel="noopener">&copy; MapTiler</a> <a
            href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">&copy; OpenStreetMap
            contributors</a></p>

    <script>
        const map = L.map('map').setView([49.2125578, 16.62662018], 14);

        var lines = [
            {
                coords: [
                    [49.210000, 16.620000],
                    [49.215000, 16.620000],
                    [49.215000, 16.625000],
                    [49.210000, 16.625000],
                    [49.210000, 16.620000]
                ],
                label: 'SS',
                id: '219312936189461238461289348123'
            },
            {
                coords: [
                    [49.210000, 16.620000],
                    [49.215000, 16.625000],
                    [49.210000, 16.630000],
                    [49.205000, 16.625000],
                    [49.210000, 16.620000]
                ],
                label: 'DD',
                id: '123412834671239841293462398746'
            }
        ];

        function calculateBearing(lat1, lon1, lat2, lon2) {
            const toRad = (val) => val * Math.PI / 180;
            const toDeg = (val) => val * 180 / Math.PI;
            const dLon = toRad(lon2 - lon1);
            const lat1Rad = toRad(lat1);
            const lat2Rad = toRad(lat2);
            const y = Math.sin(dLon) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
            let bearing = toDeg(Math.atan2(y, x));
            return (bearing + 360) % 360;
        }

        function interpolateCoord(lat1, lon1, lat2, lon2, factor) {
            const lat = lat1 + (lat2 - lat1) * factor;
            const lon = lon1 + (lon2 - lon1) * factor;
            return [lat, lon];
        }

        let linesAndMarkers = [];
        let pointsEdit = [];
        let currentlyDragging = null;

        const updateLineDraw = (lineId) => {
            linesAndMarkers.filter(x => x?.options?.lineId === lineId).forEach(layer => map.removeLayer(layer));
            linesAndMarkers = linesAndMarkers.filter(x => x?.options?.lineId !== lineId);
            const line = lines.find(x => x.id === lineId);
            drawLineDraw(line);
        }
        const drawPointCenter = (lineId, midpointCenter, indexStart) => {
            let pointDrawCenter = L.marker(midpointCenter, {
                lineId,
                indexDraw: indexStart + 1,
                isCenter: true,
                draggable: true,
                icon: L.divIcon({
                    className: 'pointDrawCenter',
                    iconSize: [15, 15],
                    iconAnchor: [10, 10]
                })
            }).addTo(map);
            linesAndMarkers.push(pointDrawCenter)
            pointDrawCenter.on('mouseover', function (e) {
                if (e.target.options?.isCenter) {
                    e.target.setIcon(L.divIcon({
                        className: 'pointDraw',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10],
                    }));
                }
            });
            pointDrawCenter.on('mouseout', function (e) {
                if (e.target.options?.isCenter) {
                    e.target.setIcon(L.divIcon({
                        className: 'pointDrawCenter',
                        iconSize: [15, 15],
                        iconAnchor: [10, 10],
                    }));
                }
            });
            pointDrawCenter.on('mousedown', function (e) {
                const newLatLng = e.target.getLatLng();
                const indexDraw = e.target.options.indexDraw;
                const pointIndex = parseInt(indexDraw);
                const markerIndex = linesAndMarkers.indexOf(pointDrawCenter);
                if (markerIndex > -1) {
                    linesAndMarkers.splice(markerIndex, 1);
                    lines.forEach(l => {
                        if (l.id === lineId) {
                            l.coords.splice(pointIndex, 0, [newLatLng.lat, newLatLng.lng]);
                        }
                    });
                    e.target.options.isCenter = false;
                    pointsEdit.push(pointDrawCenter);
                    updateLineDraw(lineId);
                }
            });

            pointDrawCenter.on('click', function (e) {
                currentlyDragging = e.target;
                pointsEdit.forEach(marker => {
                    marker.dragging.disable()
                });
                currentlyDragging.dragging.enable();
            });

            pointDrawCenter.on('drag', function (e) {
                const newLatLng = e.target.getLatLng();
                const indexDraw = e.target.options.indexDraw;
                const pointIndex = parseInt(indexDraw);
                lines.forEach(l => {
                    if (l.id === lineId) {
                        l.coords = l.coords.map(x => {
                            if (x[0] === l.coords[pointIndex][0] && x[1] === l.coords[pointIndex][1]) {
                                return [newLatLng.lat, newLatLng.lng];
                            }
                            return x;
                        });
                    }
                });
                updateLineDraw(lineId);
            });

            pointDrawCenter.on('dragend', function () {
                currentlyDragging = null;
                placeLinesAndMarkers();
            });
        }
        const drawLineDraw = (line) => {
            let coordsAll = line.coords;
            let label = line.label;
            let lineSegments = [];
            let lineId = line.id;
            for (let i = 0; i < coordsAll.length - 1; i++) {
                lineSegments.push({
                    coords: [coordsAll[i], coordsAll[i + 1]],
                    indexStart: i,
                });
            }
            lineSegments.forEach(data => {
                const coords = data.coords;
                const indexStart = data.indexStart;
                const totalLengthPx = map.latLngToLayerPoint(coords[0]).distanceTo(map.latLngToLayerPoint(coords[1]));
                const labelLengthPx = (label.length * 15);
                const numDashes = Math.floor(totalLengthPx / labelLengthPx);
                const distance = map.distance(L.latLng(coords[0][0], coords[0][1]), L.latLng(coords[1][0], coords[1][1]));
                const distanceLabel = `${distance.toFixed(2)} m`;
                const bearing = calculateBearing(coords[0][0], coords[0][1], coords[1][0], coords[1][1]);
                const latMidCenter = (coords[0][0] + coords[1][0]) / 2;
                const lngMidCenter = (coords[0][1] + coords[1][1]) / 2;
                const midpointCenter = L.latLng(latMidCenter, lngMidCenter);
                const labelLengthCenterPx = (distanceLabel.length * 15);
                let layer = L.marker(midpointCenter, {
                    icon: L.divIcon({
                        className: 'labelLineCenter',
                        html: `<div style="transform: rotate(${bearing + 90}deg); display: flex; justify-content: center; width: 100%; height: 100%;">${distanceLabel}</div>`,
                        iconSize: [labelLengthCenterPx / 2, labelLengthCenterPx / 2],
                    }),
                    lineId
                }).addTo(map);
                linesAndMarkers.push(layer);
                drawPointCenter(lineId, midpointCenter, indexStart)
                for (let i = 0; i < numDashes; i++) {
                    const factor1 = i / numDashes;
                    let point1 = interpolateCoord(
                        coords[0][0],
                        coords[0][1],
                        coords[1][0],
                        coords[1][1],
                        factor1
                    );
                    const factor2 = (i + 1) / numDashes;
                    let point2 = interpolateCoord(
                        coords[0][0],
                        coords[0][1],
                        coords[1][0],
                        coords[1][1],
                        factor2
                    );
                    const latMid = (point1[0] + point2[0]) / 2;
                    const lngMid = (point1[1] + point2[1]) / 2;
                    const midpoint = L.latLng(latMid, lngMid);
                    if (i % 2 !== 0) {
                        let layer = L.marker(midpoint, {
                            icon: L.divIcon({
                                className: 'labelLine',
                                html: `<div style="transform: rotate(${bearing + 90}deg); display: flex; justify-content: center; align-items: center; width: 100%; height: 100%;">${label}</div>`,
                                iconSize: [labelLengthPx / 2, labelLengthPx / 2],
                            }),
                            lineId
                        }).addTo(map);
                        linesAndMarkers.push(layer);
                    } else {
                        let layer = L.polyline([point1, point2], {
                            color: 'red',
                            weight: 6,
                            lineId
                        }).addTo(map);
                        linesAndMarkers.push(layer);
                    }
                }
            });
        }
        const placeLinesAndMarkers = () => {
            linesAndMarkers.forEach(layer => map.removeLayer(layer));
            linesAndMarkers = [];
            pointsEdit.forEach(layer => map.removeLayer(layer));
            pointsEdit = [];
            lines.forEach(line => {
                let coordsAll = line.coords;
                let lineId = line.id;
                for (let i = 0; i < coordsAll.length - 1; i++) {
                    let pointDraw = L.marker(coordsAll[i], {
                        lineId,
                        indexDraw: i,
                        draggable: true,
                        icon: L.divIcon({
                            className: 'pointDraw',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    }).addTo(map);

                    pointDraw.on('click', function (e) {
                        currentlyDragging = e.target;
                        pointsEdit.forEach(marker => {
                            marker.dragging.disable()
                        });
                        currentlyDragging.dragging.enable();
                    });

                    pointDraw.on('drag', function (e) {
                        const newLatLng = e.target.getLatLng();
                        const indexDraw = e.target.options.indexDraw;
                        const pointIndex = parseInt(indexDraw);
                        lines.forEach(l => {
                            if (l.id === lineId) {
                                l.coords = l.coords.map(x => {
                                    if (x[0] === l.coords[pointIndex][0] && x[1] === l.coords[pointIndex][1]) {
                                        return [newLatLng.lat, newLatLng.lng];
                                    }
                                    return x;
                                });
                            }
                        });
                        updateLineDraw(lineId);
                    });

                    pointDraw.on('dragend', function () {
                        currentlyDragging = null;
                        placeLinesAndMarkers();
                    });

                    pointsEdit.push(pointDraw);
                }
                drawLineDraw(line);
            });
        }

        placeLinesAndMarkers();
        map.on('zoomend', function () {
            placeLinesAndMarkers();
        });
        map.fitBounds(L.polyline(lines[0].coords).getBounds());
    </script>
</body>

</html>